#!/usr/bin/env node

// This is a service listening for graphite formatted data (carbon protocol)
// on a TCP port, parses it, then send the rsults to Splunk's HTTP Event 
// Collector REST API in JSON format. It's intended use is to send perfdata  
// generated by CheckMK version 1.4.0+ with the "Send to InfluxDB/Graphite"

// Carbon procotol sends datapoints as LF terminated records and each record 
// is made of 3 fields, space separated: "measurement value timestamp"

// In our case the "measurement" field is a dot separated composite of:
// "host_name.service.metric.data_type"
 
// The last field is optional and represents the MIN, MAX, WARN and CRIT
// values as created by CheckMK's checks.

// The meaning of these values is described in the pnp4nagios docs:
// https://docs.pnp4nagios.org/pnp-0.6/perfdata_format

// Example:
// server1.Postfix_Queue.size 44 1478702685
// server1.Postfix_Queue.mail_queue_active_length 0 1478702685
// server1.Postfix_Queue.mail_queue_active_length.warn 10 1478702685
// server1.Postfix_Queue.mail_queue_active_length.crit 20 1478702685
// server1.Postfix_Queue.mail_queue_active_size 4 1478702685

const dns = require('dns');
const net = require('net');
const async = require('async');
const bunyan = require('bunyan');
const request = require('request');

if (process.env.G2S_ENV !== 'PROD') {
	// Ignore TLS certificarte errors for auto-signed certs
	process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";

	// Loads a heapdump facility: 
	//  * invoke with "kill -USR2 <pid of node process>"
    //  * analyze with Chrome's WebDev tools
	const heapdump = require('heapdump');
}

// Listener TCP
const port = process.env.G2S_LISTEN_PORT || 2004;
const address = process.env.G2S_LISTEN_ADDRESS || '0.0.0.0'

// Splunk configuration
const splunkHost  = process.env.G2S_SPLUNK_HOST || null;
const splunkPort  = process.env.G2S_SPLUNK_PORT || 8088;
const splunkPath  = process.env.G2S_SPLUNK_PATH || '/services/collector/event';
const splunkToken = process.env.G2S_SPLUNK_PATH || null;

const restrainedRequest = request.defaults({
    pool: {maxSockets: 10}
});

const logger = bunyan.createLogger({
    name: 'graphite2splunk',
    streams: [{
        type: 'rotating-file',
        path: process.env.G2S_LOG_FILE || '/var/log/graphite2splunk.log',
        period: '1d',   // daily rotation
        count: 3        // keep 3 backup copies
    }]
});

logger.level(bunyan.INFO);

function parseDataPoint(data, hostname) {
    let measurement = data[0].split('.');
    let dataPoint = {
        event: {},
        host: hostname,
        time: data[2]
    };

    dataPoint.event.value      = data[1];
    dataPoint.event.mon_host   = measurement[0].replace('_','.');
    dataPoint.event.check_name = measurement[1];
    dataPoint.event.metric     = measurement[2];
    dataPoint.event.type       = 'SERVICE';

    if (measurement.length > 3) {
        dataPoint.event.threshold = measurement[3];
    } else {
        dataPoint.event.threshold = 'actual';
    }

    return dataPoint;
};

// Feature request, resolve and log the name of the client
function resolveDns(callback) {
    dns.reverse(socket.remoteAddress, function(err, hostnames) {
        if (err) {
            return callback(err);
        }
        logger.debug({ip: socket.remoteAddress, names: hostnames}, 'resolved');
        callback(null, hostnames);
	});
};

// Schedule a call to Splunk HTTP Event Collector API
function callSplunk(hostnames, callback) {
	// Use the first result only
    let shortName = hostnames[0].split('.')[0];
    let splunkEvent = parseDataPoint(line.split(' '), shortName);
    let options = {
        url: splunkProto + '://' + splunkHost + ':' + splunkPort + '/' + splunkPath,
        method: 'POST',
        json: true,
        headers: {
            Authorization: 'Splunk ' + splunkToken
        },
        body: splunkEvent
    }

    logger.debug(options, 'sending request');

    setTimeout(function() {
        restrainedRequest(options, function(err, response, body) {
            callback(err, response, body);
        });
    }, 0);
}

const server = net.createServer(function(socket) {
    logger.info({ip: socket.remoteAddress}, 'Connection from checkmk');
    socket.setEncoding('utf8');

    let data = '';
    socket.on('data', function(chunk) {
        logger.debug(chunk,'data received');

        data += chunk;
        let dataIndex = data.indexOf('\n');

        // call Splunk
        while (dataIndex > -1) {
            let line =  data.substring(0, dataIndex);
            if(line) {
            	async.series([
                    resolveDns,
                    callSplunk
                ],
                // Handles errors and final response
                function(err, response, body) {
                    if (err) {
                        return logger.error(err, 'Splunk API Error');
                    }
                    logger.debug({message: 'response', data: body});
                });
            }
            data = data.substring(dataIndex+1);
            dataIndex = data.indexOf('\n');
        };
    });

    socket.on('error', function(err) {
        logger.error({error: err}, 'TCP Socket Error');
    });

    socket.on('end', function() {
        logger.info({remote: socket.remoteAddress}, 'CMK connection terminated');
    });
});

server.on('error', function(error) {
    logger.error(error, 'TCP Server Error');
});

logger.info('launching server on port %d', port);
server.listen(port, address);

